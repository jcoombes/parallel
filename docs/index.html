<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asynchronous Programming in Python and Rust - PyCon DE & PyData 2025</title>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Reveal.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.5/dist/reset.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.5/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.5/dist/theme/black.css" id="theme">
    
    <!-- Highlight.js and theme -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/vs2015.css">
    
    <!-- Custom styles -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <!-- SECTION 1: INTRODUCTION -->
            <section>
                <h1>ðŸ¦€ RÃ¼stzeit</h1>
                <h3>Asynchronous and Concurrent Optimisation in Python and Rust</h3>
                <p>Jamie Coombes</p>
                <p class="conference-info">PyCon DE & PyData 2025</p>
                <p class="conference-track">PyCon: Rust</p>
                <p class="conference-date">23. - 25. April 2025</p>
                <p class="location">Darmstadtium, Darmstadt, Deutschland</p>
            </section>

            <!-- Talk Overview -->
            <section>
                <ol>
                    <li><strong>Main Talk Question</strong>
                        <p>Python/Rust Interop and David Hewitt's free-threaded python atop Tokio question.</p>
                    </li>
                    <li><strong>Asynchronous Concurrency</strong>
                        <p>Exploring async foundations through Rayon and Tokio in Rust, compared with Python's approaches.</p>
                    </li>
                    <li><strong>Case Study: A million monkeys at a million typewriters</strong>
                        <p>Parallelising and benchmarking a genetic algorithm for evolving text into Shakespeare quotes.</p>
                    </li>
                    <li><strong>Conclusion</strong>
                        <p>Exploring the future of Python/Rust Interop and the potential for free-threaded Python atop Tokio.</p>
                    </li>
                </ol>
            </section>

            <!-- Test Mermaid Section with vertical slides -->
            <section>
                <!-- Top slide with basic diagram -->
                <section>
                    <h2>Test Mermaid Diagram</h2>
                    <div class="mermaid">
                        flowchart TD
                            A[Start] --> B{Decision}
                            B -->|Yes| C[Do Something]
                            B -->|No| D[Do Nothing]
                            C --> E[End]
                            D --> E
                    </div>
                    <p><small>â†“ Press down for more examples</small></p>
                </section>

                <!-- Example image slide -->
                <section>
                    <h2>Example Image</h2>
                    <img src="images/flame-graph.png" alt="Example Flame Graph" style="height: 400px;">
                    <p><small>Example performance flame graph visualization</small></p>
                </section>

                <!-- Example complex diagram slide -->
                <section>
                    <h2>Example Complex Diagram</h2>
                    <div class="mermaid">
                        flowchart LR
                            A[Python Code] -->|PyO3| B{Rust Bridge}
                            B -->|Async| C[Tokio Runtime]
                            B -->|Sync| D[Native Thread]
                            C -->|Events| E[IO Operations]
                            D -->|Compute| F[CPU Tasks]
                            E --> B
                            F --> B
                    </div>
                    <p><small>Python-Rust interop architecture diagram</small></p>
                </section>
            </section>

            <!-- Inciting Question -->
            <section>
                <section>
                    <h2>The Main Talk Question</h2>
                    <blockquote>
                        "Do we want to expose the tokio event loop as the basis for a Python async runtime?"
                    </blockquote>
                    <p>â€” David Hewitt <a href="https://x.com/davidhewittdev">@davidhewittdev</a> - Rust Nation UK 2025</p>
                </section>

                <!-- Async Runtime Diagram -->
                <section>
                    <h2>Wie, bitte?</h2>
                    <img src="assets/tokio-based-python-runtime-dark.svg" alt="Comparison of single-threaded asyncio vs multi-threaded tokio-based Python runtime">
                </section>
            </section>

            <!-- Rust/Python Interop Growth -->
             <section>
            <section>
                <h2>Python/Rust Interop Growth</h2>
                <img src="images/pypi-rust-growth.png" alt="Growth of PyPI packages with Rust components.">
            </section>
            <section>
                <ul>
                    <h2>Rust/Python Interop Growth</h2>
                    <li>Rust language as preferred developer-experience for writing native python extensions.</li>
                    <li>RIIR - Rewrite It In Rust - for 10x-80x* performance improvements</li>
                    <li>PyO3 is the most popular Rust library for Python interop.</li>
                    <li>Maturin is the most popular tool for building and distributing Rust Python packages.</li>
                    <small>*performance benchmarking is hard, see flame graphs later</small>
                </ul>
            </section>
        </section>

            <section>
                <h2>Why It Matters</h2>
                <div class="two-columns">
                    <div class="column">
                        <h3>Memory Efficiency</h3>
                        <ul>
                            <li>Tokio vs Go</li>
                            <li>Tokio vs BEAM VM languages</li>
                        </ul>
                    </div>
                    <div class="column">
                        <h3>Future Impact</h3>
                        <ul>
                            <li>Python free-threading in 3.13</li>
                            <li>Integration opportunities</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section>
                <h2>Free Threading in Python</h2>
                <p>Python 3.13 shipped an experimental variant without the "Global Interpreter Lock"
                <ul>
                    <li>Expected to become the default in a few years</li>
                    <li>PyO3 supports fully</li>
                    <li>Rust's Send + Sync traits make it straightforward to reason about threading issues</li>
                </ul>
            </section>

            <!-- SECTION 2: FOUNDATIONS OF ASYNC PROGRAMMING -->
            <section>
                <h2>Foundations of Async Programming</h2>
                <h3>Concurrency vs Parallelism</h3>
                <div class="chart-placeholder">
                    [Diagram: Concurrency vs Parallelism from Rust book]
                </div>
                <p>"If something happens in parallel, then it also happens concurrently, but the opposite is not true"</p>
            </section>

            <section>
                <h2>CPU-bound vs IO-bound Tasks</h2>
                <div class="two-columns">
                    <div class="column">
                        <h3>CPU-bound</h3>
                        <ul>
                            <li>Video export</li>
                            <li>Image processing</li>
                            <li>Complex calculations</li>
                        </ul>
                    </div>
                    <div class="column">
                        <h3>IO-bound</h3>
                        <ul>
                            <li>File downloads</li>
                            <li>Database queries</li>
                            <li>Network operations</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section>
                <h2>Async Programming Models</h2>
                <ul>
                    <li>Message passing vs shared state</li>
                    <li>Structured concurrency</li>
                    <li>Brief Python async history:
                        <ul>
                            <li>Twisted â†’ generators â†’ asyncio â†’ Trio</li>
                        </ul>
                    </li>
                </ul>
            </section>

            <!-- Rayon section - vertical slide group -->
            <section>
                <!-- Main/top slide with concepts -->
                <section>
                    <h2>Rayon: Simple Parallelism in Rust</h2>
                    <div class="two-columns">
                        <div class="column">
                            <h3>Iterator Traits</h3>
                            <ul>
                                <li><code>iter()</code>: Sequential iteration</li>
                                <li><code>par_iter()</code>: Parallel iteration</li>
                                <li>Drop-in replacement API</li>
                            </ul>
                        </div>
                        <div class="column">
                            <h3>Key Features</h3>
                            <ul>
                                <li>Work stealing scheduler</li>
                                <li>Data race prevention</li>
                                <li>Automatic chunking</li>
                            </ul>
                        </div>
                    </div>
                    <p><small>â†“ Press down for implementation example</small></p>
                </section>

                <!-- Code slide below -->
                <section>
                    <h2>Parallel Iterator Example</h2>
                    <pre><code class="rust">use rayon::prelude::*; 

fn counter() -> u32 { 
    let mut counter: u32 = 0; 
    for _ in 0..1_000_000 { counter += 1; } 
    counter 
} 

fn main() { 
    let range: Vec<u32> = (0..8).collect(); 
    let counter: u32 = range
        .par_iter()  // Parallel iteration
        .map(|_| counter())
        .sum(); 
    println!("{counter}"); 
}</code></pre>
                    <p><small>Simply changing <code>iter()</code> to <code>par_iter()</code> enables parallel execution</small></p>
                </section>
            </section>

            <!-- Tokio section - vertical slide group -->
            <section>
                <!-- Main/top slide with concepts -->
                <section>
                    <h2>Tokio: Async Runtime in Rust</h2>
                    <ul>
                        <li>Event loop model</li>
                        <li>Tasks, Spawning, and Futures</li>
                        <li>Channels for communication</li>
                        <li>Zero-cost abstractions</li>
                        <li>Efficient resource utilization</li>
                    </ul>
                    <p><small>â†“ Press down for MPSC channel example</small></p>
                </section>

                <!-- Code slide below -->
                <section>
                    <h2>MPSC Channel Example</h2>
                    <pre><code class="rust">use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(100);
    
    tokio::spawn(async move {
        for i in 0..10 {
            tx.send(i).await.unwrap();
        }
    });
    
    while let Some(i) = rx.recv().await {
        println!("got = {}", i);
    }
}</code></pre>
                    <p><small>Multi-producer, single-consumer channel with backpressure control</small></p>
                </section>
            </section>

            <section>
                <h2>Python's Async Approaches</h2>
                <div class="two-columns">
                    <div class="column">
                        <h3>concurrent.futures</h3>
                        <ul>
                            <li>ThreadPoolExecutor</li>
                            <li>ProcessPoolExecutor</li>
                        </ul>
                    </div>
                    <div class="column">
                        <h3>asyncio</h3>
                        <ul>
                            <li>Event loop</li>
                            <li>coroutines</li>
                            <li>Tasks</li>
                        </ul>
                    </div>
                </div>
                <p>InterpreterPoolExecutors (future)</p>
            </section>

            <!-- SECTION 3: CASE STUDY - GENETIC ALGORITHM -->
            <section>
                <h2>Case Study: Genetic Algorithm</h2>
                <h3>"A Million Monkeys at a Million Typewriters"</h3>
                <p>Evolving random text into Hamlet quotes</p>
                <blockquote>"Brevity is the soul of wit"</blockquote>
                <p><em>(Also the soul of optimization)</em></p>
            </section>

            <section>
                <h2>Key Parameters in Genetic Algorithms</h2>
                <ul>
                    <li><strong>Population size:</strong> Controls exploration breadth</li>
                    <li><strong>Mutation rate:</strong> Enables discovering new traits</li>
                    <li><strong>Selection pressure:</strong> Balances exploitation vs exploration</li>
                    <li><strong>Crossover rate:</strong> Combines successful traits</li>
                </ul>
            </section>

            <section>
                <h2>Visualizing Crossover in High-Dimensional Space</h2>
                <ul>
                    <li>40-character string = 40D vector</li>
                    <li>Single-point crossover at position 15</li>
                    <li>Combining orthogonal projections</li>
                </ul>
                <div class="chart-placeholder">
                    [Visualization of string crossover in vector space]
                </div>
            </section>

            <!-- Python Implementation section - vertical slide group -->
            <section>
                <!-- Main/top slide with concepts -->
                <section>
                    <h2>Sequential Implementation</h2>
                    <h3>Core Components</h3>
                    <ul>
                        <li><strong>Population Management:</strong> Random initialization and generational tracking</li>
                        <li><strong>Fitness Calculation:</strong> Character-by-character matching</li>
                        <li><strong>Selection:</strong> Fitness-proportional sampling</li>
                        <li><strong>Reproduction:</strong> Crossover and mutation operations</li>
                    </ul>
                    <p><small>â†“ Press down for code implementation</small></p>
                </section>

                <!-- Code slide below -->
                <section>
                    <h2>Basic Genetic Algorithm</h2>
                    <pre><code class="python">def evolve_text(target, pop_size=1000, mutation_rate=0.01):
    # Create initial population
    population = [''.join(random.choice(CHARS) 
                for _ in range(len(target))) 
                for _ in range(pop_size)]
    
    generation = 0
    best_fit = 0
    
    while best_fit < len(target):
        # Calculate fitness for each member
        fitness_scores = [calculate_fitness(p, target) 
                         for p in population]
        
        # Selection and reproduction
        new_population = []
        for _ in range(pop_size):
            parent1 = selection(population, fitness_scores)
            parent2 = selection(population, fitness_scores)
            child = crossover(parent1, parent2)
            child = mutate(child, mutation_rate)
            new_population.append(child)
            
        population = new_population
        # ... rest of implementation</code></pre>
                    <p><small>Sequential implementation - basis for our parallel optimizations</small></p>
                </section>
            </section>

            <section>
                <h2>Initial Parallelization Strategy</h2>
                <div class="chart-placeholder">
                    [Diagram: Parallel fitness calculation pipeline]
                </div>
                <p>Pipeline model: fitness â†’ selection â†’ crossover/mutation</p>
            </section>

            <section>
                <h2>Identifying Parallelism Opportunities</h2>
                <ul>
                    <li><strong>Fitness calculation:</strong> Embarrassingly parallel</li>
                    <li><strong>Selection:</strong> Limited parallelism (requires sorting)</li>
                    <li><strong>Reproduction:</strong> Moderately parallel</li>
                </ul>
            </section>

            <!-- Tournament Selection - vertical slide group -->
            <section>
                <!-- Main/top slide -->
                <section>
                    <h2>Tournament Selection</h2>
                    <ul>
                        <li>Alternative to global sorting</li>
                        <li>Independent tournaments = better parallelism</li>
                        <li>Tunable selection pressure</li>
                        <li>Natural fit for async/await pattern</li>
                    </ul>
                    <p><small>â†“ Press down for implementation</small></p>
                </section>

                <!-- Code slide below -->
                <section>
                    <h2>Async Tournament Selection</h2>
                    <pre><code class="python">async def tournament_selection(population, fitness_func, tournament_size=5):
    # Select random individuals for tournament
    tournament = random.sample(population, tournament_size)
    
    # Calculate fitness in parallel
    tasks = [asyncio.create_task(fitness_func(ind)) 
             for ind in tournament]
    fitness_values = await asyncio.gather(*tasks)
    
    # Return the winner
    return tournament[fitness_values.index(max(fitness_values))]</code></pre>
                    <p><small>Concurrent fitness evaluation with minimal synchronization</small></p>
                </section>
            </section>

            <section>
                <h2>Asynchronous Genetic Algorithm Design</h2>
                <div class="mermaid">
                    flowchart LR
                        A[Population] --> B{Tournament<br/>Selection}
                        B -->|Winners| C[Crossover]
                        C --> D[Mutation]
                        D --> E[Fitness<br/>Evaluation]
                        E -->|Next Gen| A
                        E -->|Best| F[Output]
                </div>
                <p>Reduced synchronization points</p>
            </section>

            <!-- Optimized Population Data Structure - vertical slide group -->
            <section>
                <!-- Main/top slide -->
                <section>
                    <h2>Optimized Population Data Structure</h2>
                    <ul>
                        <li>Single central dictionary with generation index</li>
                        <li>Memory efficiency considerations</li>
                        <li>Automatic cleanup of older generations</li>
                    </ul>
                    <p><small>â†“ Press down for implementation details</small></p>
                </section>

                <!-- Code slide below -->
                <section>
                    <h2>Implementation Details</h2>
                    <pre><code class="python">class Population:
    def __init__(self, max_generations_to_keep=3):
        self.members = {}  # {generation: [members]}
        self.max_generations = max_generations_to_keep
        self.current_generation = 0
        self.lock = asyncio.Lock()
        
    async def add_member(self, member):
        async with self.lock:
            if member.generation not in self.members:
                self.members[member.generation] = []
            self.members[member.generation].append(member)
            
    async def cleanup_old_generations(self):
        async with self.lock:
            generations = sorted(self.members.keys())
            to_remove = generations[:-self.max_generations] \
                if len(generations) > self.max_generations else []
            for gen in to_remove:
                del self.members[gen]</code></pre>
                    <p><small>Thread-safe population management with generational garbage collection</small></p>
                </section>
            </section>

            <section>
                <h2>Performance Comparison</h2>
                <div class="chart-placeholder">
                    [Flame graph comparing Python vs Rust implementation]
                </div>
                <p>Key bottlenecks identified:</p>
                <ul>
                    <li>Fitness calculation in Python</li>
                    <li>GIL contention</li>
                    <li>Memory allocation patterns</li>
                </ul>
            </section>

            <!-- SECTION 4: CONCLUSION -->
            <section>
                <h2>Evolution of Our Implementation</h2>
                <ol>
                    <li>Initial implementation</li>
                    <li>Understanding execution model</li>
                    <li>Tournament selection for parallelism</li>
                    <li>Generation-aware asynchronous approach</li>
                </ol>
            </section>

            <section>
                <h2>Returning to the Initial Question</h2>
                <blockquote>
                    "Would Pythonistas benefit from free-threaded Python atop the Tokio runtime?"
                </blockquote>
                <p>My thoughts:</p>
                <ul>
                    <li>Potential for substantial performance gains</li>
                    <li>Challenges in API design and mental model</li>
                    <li>Integration complexity considerations</li>
                </ul>
            </section>

            <section>
                <h2>Next Steps and Resources</h2>
                <div class="two-columns">
                    <div class="column">
                        <h3>Communities</h3>
                        <ul>
                            <li>Discord: #python-rust-interop</li>
                            <li>Reddit: r/rustpython</li>
                            <li>GitHub: PyO3 organization</li>
                        </ul>
                    </div>
                    <div class="column">
                        <h3>Learning Resources</h3>
                        <ul>
                            <li>Rust Book</li>
                            <li>Tokio Documentation</li>
                            <li>asyncio Documentation</li>
                        </ul>
                    </div>
                </div>
                <p>Your Contact Information:</p>
                <p>email@example.com | @twitter_handle | github.com/username</p>
            </section>

            <section>
                <h2>Sources and Credits</h2>
                <ul>
                    <li>Rust programming language book, rustlings, rust by example</li>
                    <li>Tokio glossary</li>
                    <li>Arden labs: Fearless Concurrency in Rust series</li>
                    <li>Piotr's performance benchmarking</li>
                    <li>David Hewitt Rust Nation UK talk</li>
                    <li>Evgenii Seliversov: Parallel Programming in Rust techniques</li>
                    <li>Personal correspondence</li>
                    <li>Claude assistance</li>
                </ul>
            </section>

            <section>
                <h1>Thank You!</h1>
                <h3>Questions?</h3>
            </section>
        </div>
    </div>

    <!-- Ferris Runner -->
    <div class="ferris-runner">
        <img src="https://rustacean.net/assets/rustacean-flat-happy.svg" alt="Ferris">
    </div>

    <!-- Load all scripts at the end of body -->
    <!-- Core libraries -->
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/languages/rust.min.js"></script>
    
    <!-- Reveal.js and its plugins -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.5/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.5/plugin/markdown/markdown.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.5/plugin/highlight/highlight.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.5/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.5/plugin/math/math.js"></script>
    
    <!-- Mermaid plugin -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js-mermaid-plugin@11.4.1/plugin/mermaid/mermaid.min.js"></script>
    
    <!-- Custom script - load last -->
    <script src="script.js"></script>
</body>
</html> 